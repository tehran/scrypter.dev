---
layout: single
title: Scaling and Queuing PowerShell Background Jobs
excerpt: 
permalink: /2011/08/scaling-and-queuing-powershell.html
tags: 
- background jobs
- scripting
published: true
comments: true
---

<b>Great article from Travis Jones [[Source](http://blogs.msdn.com/b/powershell/archive/2011/04/04/scaling-and-queuing-powershell-background-jobs.aspx)]</b>

A couple of months ago I had asked the PowerShell MVPs for  suggestions on blog topics. Karl Prosser, one of our awesome MVPs,  brought up the topic of scaling and queuing background jobs.
The scenario is familiar: You have a file containing a bunch of input  that you want to process and you don't want to overburden your computer  by starting up hundreds of instances of PowerShell at once to process  them.
After playing around for about an hour on Friday afternoon, here is  what I came up with... This example assumes you have a text file  containing the names of many event logs and you want to get the content  of each log.

<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: darkgreen; font-size: xx-small;"># How many jobs we should run simultaneously<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;">$maxConcurrentJobs = 3;<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;">
<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: darkgreen; font-size: xx-small;"># Read the input and queue it up<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;">$jobInput = get-content .\input.txt<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;">$queue = [System.Collections.Queue]::Synchronized( (New-Object System.Collections.Queue) )<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;">foreach($item in $jobInput)<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: black; font-size: xx-small;">{<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;"> $queue.Enqueue($item)<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: black; font-size: xx-small;">}<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;">
<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;">
<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: darkgreen; font-size: xx-small;"># Function that pops input off the queue and starts a job with it<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;">function RunJobFromQueue<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: black; font-size: xx-small;">{<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;"> if( $queue.Count -gt 0)<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;"> {<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;"> $j = Start-Job -ScriptBlock {param($x); Get-WinEvent -LogName $x} -ArgumentList $queue.Dequeue()<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-size: xx-small;"><span style="font-family: Lucida Console;"> Register-ObjectEvent -InputObject $j -EventName StateChanged -Action { RunJobFromQueue; Unregister-Event $eventsubscriber.SourceIdentifier; Remove-Job $eventsubscriber.SourceIdentifier } | Out-Null<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;"> }<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: black; font-size: xx-small;">}<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;">
<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;">
<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: darkgreen; font-size: xx-small;"># Start up to the max number of concurrent jobs <div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: darkgreen; font-size: xx-small;"># Each job will take care of running the rest<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="font-size: xx-small;">for( $i = 0; $i -lt $maxConcurrentJobs; $i++ )<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-family: Lucida Console;"><span style="color: black; font-size: xx-small;">{<div class="MsoNormal" style="line-height: normal; list-style-type: disc; margin: 0in 0in 0pt; mso-layout-grid-align: none;"><span style="font-size: xx-small;"><span style="font-family: Lucida Console;"> RunJobFromQueue<div class="MsoNormal" style="line-height: 13pt; list-style-type: disc; margin: 0in 0in 10pt;"><span style="line-height: 12pt;"><span style="font-family: Lucida Console;"><span style="color: black; font-size: xx-small;">}
The English version of this script is:

* Given a file input.txt containing the name of many event logs, queue up each line of input 

* Kick off a small number of jobs to process one line of input each. Each job just gets the content of a particular log. 

* When a job finishes (determined by the StateChanged Event), start a new job with the next piece of input from the queue 

* Clean up the jobs corresponding to the event subscription so at the end we only have jobs containing event data 
The "Synchronized" code you see when defining the queue is just for  good measure to make sure that only one job can access it at a time. 
Have something you want to see on the PowerShell blog? Leave a  comment... Can't promise we'll get to everything but it's nice to see what  everyone is interested in.

Travis Jones 
Windows PowerShell PM 
Microsoft Corporation
